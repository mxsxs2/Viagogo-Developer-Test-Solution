//Viagogo Developer Test Solution By Krisztian Nagy - mxsxs2@gmail.com
package main

import (
	"math/rand"
	"time"
)

//The base currency
const BASECURRECNY = "USD"

//The highest coordinate for both X and Y
const COORDMAX = 10

//The lowest coordinate for both X and Y
const COORDMIN = -10

//The number of results to show to the user
const NUMBEROFRESULTS = 5

//As the documentation did not clarify how many events and tickects should I have, I decided to generate random amount of them

//The maximum number of events generated by the data generator
const MAXSEEDDATA = 100

//The minimum number of events generated by the data generator
const MINSEEDDATA = 10

//The maximum number of tickets generated by the data generator for each ticket
const MAXNUMBEROFTICKETS = 50

//The minimum number of tickets generated by the data generator for each ticket
const MINNUMBEROFTICKETS = 10

//The masimum price of a the ticket
const MAXTICKETPRICE = 500

//Structure for a single pair of coordinates
type Coordinates struct {
	//The coordinates set to be floats as in realworld they are floats as well
	x float64
	y float64
}

//Structure for a single ticket
type Ticket struct {
	ticketID int     //I assume every ticket should have an identifier
	price    float64 //The non zero price
}

//Structure for a single event
type Event struct {
	eventID  int         //Unique event identifier
	tickets  []Ticket    //The set of tickets
	location Coordinates //The event location
}

//Function used to generate random numbers
func random(min, max int) float64 {

	//Create the random number in boundaries.
	return rand.Float64()*float64((max-min)) + float64(min)
}

//Function used to generate random events
func generateSeedData() []Event {
	//Seed the random number generator
	rand.Seed(time.Now().UnixNano())

	//The empty holder for the events
	eventPool := []Event{}
	//The number of generated events. It is down casted to int for the loop
	numofEvents := int(random(MINSEEDDATA, MAXSEEDDATA))

	//Do a loop to generate the events
	for i := 1; i <= numofEvents; i++ {
		//Create an event
		event := Event{
			//Set the event id, which is unique as it is the iteration number
			eventID: i,
			//Generate the unique location
			location: generateRandomCoordinates(true, eventPool),
			//Generate a random number of tickets
			tickets: generateRandomTickets(),
		}

		//Add the event to the pool
		eventPool = append(eventPool, event)
	}
	//Return the events
	return eventPool
}

/*Function used to generate random coordinates
  The coordinates can be either unique or not
  If the the coordinates has to be uniqe, the function should receive an event slice to compare the coordinates to, otherwise just an empty event slice is enough*/
func generateRandomCoordinates(unique bool, eventPool []Event) Coordinates {
	//Create new coordinates holder
	coordinates := Coordinates{
		//Generate the x coordinate
		x: random(COORDMIN, COORDMAX),
		//Generate the y coordinate
		y: random(COORDMIN, COORDMAX),
	}

	//If the unique flag is on then loop the event pool to check if it is unique or not
	if unique {
		//Loop the events
		for _, event := range eventPool {
			//If the coordinates exists
			if event.location == coordinates {
				//Call the random coordinates generator again and return the value of it
				return generateRandomCoordinates(unique, eventPool)
			}
		}
	}

	//If the coordinates does not have to be uniqe then just return the generated ones
	return coordinates
}

/*Function used to generate random amount of tickets
  It may generate the same ticket price once or more as there was no requirement specified
  The ticket id maybe the same for one or more events, therefore when we are talking about a uniqe ticket is should be in the format of:
  Eventid:TicketID
*/
func generateRandomTickets() []Ticket {
	//The empty holder for the tickets
	ticketPool := []Ticket{}
	//The number of generated tickets. It is down casted to int for the loop
	numofTickets := int(random(MINNUMBEROFTICKETS, MAXNUMBEROFTICKETS))
	//Do a loop to generate the tickests
	for i := 1; i <= numofTickets; i++ {
		ticket := Ticket{
			//Set the event id, which is unique for the current event as it is the iteration number
			ticketID: i,
			//Randomly genertate a non-zero ticket price
			price: random(1, MAXTICKETPRICE),
		}
		//Add the ticket to the ticket pool
		ticketPool = append(ticketPool, ticket)
	}
	//Return the tickest
	return ticketPool
}
